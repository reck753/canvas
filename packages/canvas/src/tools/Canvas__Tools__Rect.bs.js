// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Uuid from "uuid";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Canvas__StateUtils from "../Canvas__StateUtils.bs.js";
import * as Canvas__ElementUtils from "../Canvas__ElementUtils.bs.js";

var tool_engine = {
  type: "Rect",
  _0: {
    canResizeVertically: true,
    canResizeHorizontally: true
  }
};

function tool_onStart(param) {
  var match = param.store;
  var snapToGrid = match.snapToGrid;
  var clientY = param.clientY;
  var clientX = param.clientX;
  var state = Canvas__StateUtils.getRectState(match.state);
  var match$1;
  if (typeof snapToGrid !== "object") {
    match$1 = [
      clientX,
      clientY
    ];
  } else {
    var gridSize = snapToGrid._0;
    match$1 = [
      Canvas__ElementUtils.roundNumberBySnapGridSize(clientX, gridSize),
      Canvas__ElementUtils.roundNumberBySnapGridSize(clientY, gridSize)
    ];
  }
  if (state === undefined) {
    return ;
  }
  if (state !== "Idle") {
    return ;
  }
  var element = {
    type: "Rect",
    _0: {
      id: Uuid.v4(),
      toolId: match.selectedToolId,
      zIndex: param.nextIndex,
      x: match$1[0],
      y: match$1[1],
      width: 0,
      height: 0
    }
  };
  param.updateStore(function (prev) {
        return {
                state: {
                  type: "Rect",
                  _0: "Drawing"
                },
                snapToGrid: prev.snapToGrid,
                selectedToolId: prev.selectedToolId,
                selectedElementIds: prev.selectedElementIds,
                elements: prev.elements.concat([element])
              };
      });
}

function tool_onMove(param) {
  var match = param.store;
  var elements = match.elements;
  var state = Canvas__StateUtils.getRectState(match.state);
  var position = elements.length - 1 | 0;
  var element = elements[position];
  if (state === undefined) {
    return ;
  }
  if (state === "Idle") {
    param.target.style.cursor = "crosshair";
    return ;
  }
  if (element === undefined) {
    return ;
  }
  if (element.type === "Line") {
    return ;
  }
  var rect = element._0;
  var newrecord = Caml_obj.obj_dup(rect);
  var element$1 = {
    type: "Rect",
    _0: (newrecord.height = param.clientY - rect.y, newrecord.width = param.clientX - rect.x, newrecord)
  };
  param.updateStore(function (prev) {
        return {
                state: prev.state,
                snapToGrid: prev.snapToGrid,
                selectedToolId: prev.selectedToolId,
                selectedElementIds: prev.selectedElementIds,
                elements: Canvas__ElementUtils.updateElementAtPosition(prev.elements, position, element$1)
              };
      });
}

function tool_onEnd(param) {
  var updateStore = param.updateStore;
  var match = param.store;
  var elements = match.elements;
  var snapToGrid = match.snapToGrid;
  var state = Canvas__StateUtils.getRectState(match.state);
  if (state === undefined) {
    return ;
  }
  if (typeof snapToGrid !== "object") {
    return updateStore(function (prev) {
                return {
                        state: {
                          type: "Rect",
                          _0: "Idle"
                        },
                        snapToGrid: prev.snapToGrid,
                        selectedToolId: prev.selectedToolId,
                        selectedElementIds: [],
                        elements: prev.elements
                      };
              });
  }
  var position = elements.length - 1 | 0;
  var element = elements[position];
  if (element === undefined) {
    return updateStore(function (prev) {
                return {
                        state: {
                          type: "Rect",
                          _0: "Idle"
                        },
                        snapToGrid: prev.snapToGrid,
                        selectedToolId: prev.selectedToolId,
                        selectedElementIds: [],
                        elements: prev.elements
                      };
              });
  }
  var element$1 = Canvas__ElementUtils.snapElementToGrid(element, snapToGrid._0);
  updateStore(function (prev) {
        return {
                state: {
                  type: "Rect",
                  _0: "Idle"
                },
                snapToGrid: prev.snapToGrid,
                selectedToolId: prev.selectedToolId,
                selectedElementIds: [],
                elements: Canvas__ElementUtils.updateElementAtPosition(prev.elements, position, element$1)
              };
      });
}

var tool = {
  toolId: "rect",
  engine: tool_engine,
  onStart: tool_onStart,
  onMove: tool_onMove,
  onEnd: tool_onEnd
};

export {
  tool ,
}
/* uuid Not a pure module */
