// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Uuid from "uuid";
import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Canvas__Style from "./Canvas__Style.bs.js";
import * as TailwindUtils from "../../tailwind-utils/src/TailwindUtils.bs.js";
import * as Canvas__ToolUtils from "./Canvas__ToolUtils.bs.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Canvas__StateUtils from "./Canvas__StateUtils.bs.js";
import * as Canvas__Tools__Line from "./tools/Canvas__Tools__Line.bs.js";
import * as Canvas__Tools__Rect from "./tools/Canvas__Tools__Rect.bs.js";
import * as Canvas__ElementUtils from "./Canvas__ElementUtils.bs.js";
import * as Canvas__Tools__Selection from "./tools/Canvas__Tools__Selection.bs.js";
import * as Canvas__Events__OnMouseUp from "./events/Canvas__Events__OnMouseUp.bs.js";
import * as Canvas__Events__OnMouseDown from "./events/Canvas__Events__OnMouseDown.bs.js";
import * as Canvas__Events__OnMouseMove from "./events/Canvas__Events__OnMouseMove.bs.js";

var newrecord = Caml_obj.obj_dup(Canvas__Tools__Line.tool);

var tools = [
  Canvas__Tools__Selection.tool,
  Canvas__Tools__Rect.tool,
  Canvas__Tools__Line.tool,
  (newrecord.engine = {
      TAG: "Line",
      _0: {
        lineWidth: 4,
        canResizeStart: false,
        canResizeEnd: false
      }
    }, newrecord.toolId = "line1", newrecord),
  {
    toolId: "rect1",
    engine: {
      TAG: "Rect",
      _0: {
        canResizeVertically: false,
        canResizeHorizontally: false
      }
    },
    onStart: (function (param) {
        var match = param.store;
        var snapToGrid = match.snapToGrid;
        var clientY = param.clientY;
        var clientX = param.clientX;
        var state = Canvas__StateUtils.getRectState(match.state);
        var match$1;
        if (typeof snapToGrid !== "object") {
          match$1 = [
            clientX,
            clientY
          ];
        } else {
          var gridSize = snapToGrid._0;
          match$1 = [
            Canvas__ElementUtils.roundNumberBySnapGridSize(clientX, gridSize),
            Canvas__ElementUtils.roundNumberBySnapGridSize(clientY, gridSize)
          ];
        }
        if (state === undefined) {
          return ;
        }
        if (state !== "Idle") {
          return ;
        }
        var element = {
          TAG: "Rect",
          _0: {
            id: Uuid.v4(),
            toolId: match.selectedToolId,
            zIndex: param.nextIndex,
            label: undefined,
            x: match$1[0] - 40 / 2,
            y: match$1[1] - 40 / 2,
            width: 40,
            height: 40
          }
        };
        param.target.style.cursor = "default";
        param.updateStore(function (prev) {
              return {
                      state: {
                        TAG: "Selection",
                        _0: "Idle"
                      },
                      snapToGrid: prev.snapToGrid,
                      selectedToolId: "selection",
                      selectedElementIds: prev.selectedElementIds,
                      elements: prev.elements.concat([element])
                    };
            });
      }),
    onMove: (function (param) {
        
      }),
    onEnd: (function (param) {
        
      }),
    onDoubleClick: (function (param) {
        var clickedElement = param.clickedElement;
        console.log("onDoubleClick", Canvas__ElementUtils.getToolId(clickedElement), Canvas__ElementUtils.getElementId(clickedElement));
      })
  }
];

function Canvas__Example(props) {
  var match = React.useState(function () {
        return {
                state: {
                  TAG: "Selection",
                  _0: "Idle"
                },
                snapToGrid: {
                  TAG: "Yes",
                  _0: 10
                },
                selectedToolId: "selection",
                selectedElementIds: [],
                elements: []
              };
      });
  var setStore = match[1];
  var store = match[0];
  React.useLayoutEffect((function () {
          var canvas = document.getElementById("canvas");
          var canvas$1 = (canvas == null) ? undefined : Caml_option.some(canvas);
          var ctx = Core__Option.flatMap(canvas$1, (function (canvas) {
                  return Caml_option.nullable_to_opt(canvas.getContext("2d"));
                }));
          if (ctx !== undefined) {
            var canvas$2 = Core__Option.getExn(canvas$1);
            ctx.clearRect(0, 0, canvas$2.width, canvas$2.height);
            ctx.strokeStyle = Canvas__Style.elementStroke;
            store.elements.forEach(function (element) {
                  var elementTool = tools.find(function (tool) {
                        return tool.toolId === Canvas__ElementUtils.getToolId(element);
                      });
                  var isSelected = Canvas__ElementUtils.isSelected(Canvas__ElementUtils.getElementId(element), store.selectedElementIds);
                  var style = Canvas__ToolUtils.getOptStyleWithDefaults(elementTool);
                  ctx.lineWidth = Canvas__ToolUtils.getLineWidth(style);
                  if (isSelected) {
                    ctx.strokeStyle = Canvas__Style.selectedElementStroke;
                  } else {
                    ctx.strokeStyle = Canvas__Style.elementStroke;
                  }
                  if (element.TAG === "Line") {
                    var line = element._0;
                    var end = line.end;
                    var start = line.start;
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.font = Canvas__Style.font;
                    if (isSelected) {
                      ctx.fillStyle = Canvas__Style.selectedElementStroke;
                    } else {
                      ctx.fillStyle = "black";
                    }
                    var text = Core__Option.getOr(line.label, line.zIndex.toString());
                    var lineCenter = Canvas__ElementUtils.getLineCenterForText(line, text, Canvas__Style.font);
                    return ctx.fillText(text, lineCenter.x, lineCenter.y);
                  }
                  var rect = element._0;
                  var height = rect.height;
                  var width = rect.width;
                  var y = rect.y;
                  var x = rect.x;
                  if (isSelected) {
                    ctx.fillStyle = Canvas__Style.selectedRectFill;
                  } else {
                    ctx.fillStyle = Canvas__Style.rectFill;
                  }
                  ctx.strokeRect(x, y, width, height);
                  ctx.fillRect(x, y, width, height);
                  ctx.font = Canvas__Style.font;
                  if (isSelected) {
                    ctx.fillStyle = Canvas__Style.selectedElementStroke;
                  } else {
                    ctx.fillStyle = "black";
                  }
                  var text$1 = Core__Option.getOr(rect.label, rect.zIndex.toString());
                  var rectCenter = Canvas__ElementUtils.getRectCenterForText(rect, text$1, Canvas__Style.font);
                  ctx.fillText(text$1, rectCenter.x, rectCenter.y);
                });
            var match = store.state;
            switch (match.TAG) {
              case "Selection" :
                  var match$1 = match._0;
                  if (typeof match$1 === "object" && match$1.TAG === "Selecting") {
                    var match$2 = match$1._0;
                    var height = match$2.height;
                    var width = match$2.width;
                    var y = match$2.y;
                    var x = match$2.x;
                    ctx.strokeStyle = Canvas__Style.selectionBoxStroke;
                    ctx.fillStyle = Canvas__Style.selectionBoxFill;
                    ctx.lineWidth = Canvas__Style.selectionBoxLineWidth;
                    ctx.strokeRect(x, y, width, height);
                    ctx.fillRect(x, y, width, height);
                  }
                  break;
              case "Rect" :
              case "Line" :
                  break;
              
            }
          }
          
        }), [store]);
  var handleMouseDown = function (e) {
    Canvas__Events__OnMouseDown.handler(e, 100, 100, store, tools, setStore);
  };
  var handleMouseMove = function (e) {
    Canvas__Events__OnMouseMove.handler(e, 100, 100, store, tools, setStore);
  };
  var handleMouseUp = function (e) {
    Canvas__Events__OnMouseUp.handler(e, 100, 100, store, tools, setStore);
  };
  var match$1 = store.state;
  var tmp;
  switch (match$1.TAG) {
    case "Selection" :
        var tmp$1 = match$1._0;
        if (typeof tmp$1 !== "object") {
          tmp = "Selection Idle";
        } else {
          switch (tmp$1.TAG) {
            case "Selecting" :
                tmp = "Selecting";
                break;
            case "Moving" :
                tmp = "Moving";
                break;
            case "Resizing" :
                tmp = "Resizing";
                break;
            
          }
        }
        break;
    case "Rect" :
        tmp = match$1._0 === "Idle" ? "Rect Idle" : "Drawing a rectangle";
        break;
    case "Line" :
        tmp = match$1._0 === "Idle" ? "Line Idle" : "Drawing a line";
        break;
    
  }
  var match$2 = store.selectedElementIds.length;
  var tmp$2;
  if (match$2 !== 1) {
    tmp$2 = null;
  } else {
    var selectedElement = store.elements.find(function (element) {
          return Canvas__ElementUtils.getElementId(element) === store.selectedElementIds[0];
        });
    if (selectedElement !== undefined) {
      var match$3 = selectedElement._0;
      var label = match$3.label;
      var id = match$3.id;
      tmp$2 = JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("span", {
                    children: "Selected element: " + Core__Option.getOr(label, match$3.zIndex.toString())
                  }),
              JsxRuntime.jsx("input", {
                    className: "max-w-[400px] border rounded p-2 h-10",
                    placeholder: "Label",
                    value: Core__Option.getOr(label, ""),
                    onChange: (function (e) {
                        e.preventDefault();
                        var value = e.target.value;
                        var label = value === "" ? undefined : Caml_option.some(value);
                        setStore(function (prev) {
                              return {
                                      state: prev.state,
                                      snapToGrid: prev.snapToGrid,
                                      selectedToolId: prev.selectedToolId,
                                      selectedElementIds: prev.selectedElementIds,
                                      elements: Canvas__ElementUtils.updateElementLabel(prev.elements, id, label)
                                    };
                            });
                      })
                  })
            ],
            className: "flex flex-col gap-2"
          });
    } else {
      tmp$2 = null;
    }
  }
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("canvas", {
                      children: "Canvas is not supported in your browser.",
                      className: "border border-black w-[700px] h-[500px] bg-white",
                      id: "canvas",
                      height: "500px",
                      width: "700px",
                      onMouseDown: handleMouseDown,
                      onMouseMove: handleMouseMove,
                      onMouseUp: handleMouseUp
                    }),
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsx("div", {
                              children: tools.map(function (tool) {
                                    return JsxRuntime.jsx("button", {
                                                children: tool.toolId.charAt(0).toUpperCase() + tool.toolId.charAt(tool.toolId.length - 1 | 0).toUpperCase(),
                                                className: TailwindUtils.cn([
                                                      "size-10 flex justify-center items-center border rounded",
                                                      store.selectedToolId === tool.toolId ? "bg-white text-black" : "bg-black text-white"
                                                    ]),
                                                onClick: (function (_e) {
                                                    setStore(function (prev) {
                                                          var match = tool.engine;
                                                          var tmp;
                                                          tmp = typeof match !== "object" ? ({
                                                                TAG: "Selection",
                                                                _0: "Idle"
                                                              }) : (
                                                              match.TAG === "Rect" ? ({
                                                                    TAG: "Rect",
                                                                    _0: "Idle"
                                                                  }) : ({
                                                                    TAG: "Line",
                                                                    _0: "Idle"
                                                                  })
                                                            );
                                                          return {
                                                                  state: tmp,
                                                                  snapToGrid: prev.snapToGrid,
                                                                  selectedToolId: tool.toolId,
                                                                  selectedElementIds: [],
                                                                  elements: prev.elements
                                                                };
                                                        });
                                                  })
                                              }, tool.toolId);
                                  }),
                              className: "flex gap-2"
                            }),
                        JsxRuntime.jsx("button", {
                              children: "X",
                              className: "size-10 flex justify-center items-center border rounded",
                              onClick: (function (_e) {
                                  setStore(function (prev) {
                                        return {
                                                state: prev.state,
                                                snapToGrid: prev.snapToGrid,
                                                selectedToolId: prev.selectedToolId,
                                                selectedElementIds: [],
                                                elements: prev.elements.filter(function (element) {
                                                      var id = Canvas__ElementUtils.getElementId(element);
                                                      return !Canvas__ElementUtils.isSelected(id, prev.selectedElementIds);
                                                    })
                                              };
                                      });
                                })
                            })
                      ],
                      className: "flex gap-2 pt-2 px-2 justify-between w-[700px]"
                    }),
                JsxRuntime.jsx("span", {
                      children: tmp
                    }),
                tmp$2
              ]
            });
}

var make = Canvas__Example;

export {
  make ,
}
/* tools Not a pure module */
