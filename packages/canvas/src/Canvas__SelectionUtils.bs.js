// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Canvas__Constants from "./Canvas__Constants.bs.js";

function normalizeRect(rect) {
  var x = rect.width >= 0 ? rect.x : rect.x + rect.width;
  var y = rect.height >= 0 ? rect.y : rect.y + rect.height;
  var width = Math.abs(rect.width);
  var height = Math.abs(rect.height);
  return {
          id: rect.id,
          toolId: rect.toolId,
          zIndex: rect.zIndex,
          label: rect.label,
          x: x,
          y: y,
          width: width,
          height: height
        };
}

function normalizeSelection(selection) {
  var x = selection.width >= 0 ? selection.x : selection.x + selection.width;
  var y = selection.height >= 0 ? selection.y : selection.y + selection.height;
  var width = Math.abs(selection.width);
  var height = Math.abs(selection.height);
  return {
          x: x,
          y: y,
          width: width,
          height: height
        };
}

function expandSelectionBox(selection, tolerance) {
  return {
          x: selection.x - tolerance,
          y: selection.y - tolerance,
          width: selection.width + 2 * tolerance,
          height: selection.height + 2 * tolerance
        };
}

function isPointInsideSelection(selection, x, y, toleranceOpt) {
  var tolerance = toleranceOpt !== undefined ? toleranceOpt : 0;
  if (x >= selection.x - tolerance && x <= selection.x + selection.width + tolerance && y >= selection.y - tolerance) {
    return y <= selection.y + selection.height + tolerance;
  } else {
    return false;
  }
}

function onSegment(px, py, qx, qy, rx, ry) {
  if (!(qx <= Math.max(px, rx) && qx >= Math.min(px, rx) && qy <= Math.max(py, ry) && qy >= Math.min(py, ry))) {
    return false;
  }
  var area = px * (qy - ry) + qx * (ry - py) + rx * (py - qy);
  return area === 0;
}

function orientation(px, py, qx, qy, rx, ry) {
  var val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy);
  if (Math.abs(val) < 1e-10) {
    return 0;
  } else if (val > 0) {
    return 2;
  } else {
    return 1;
  }
}

function doIntersect(p1x, p1y, q1x, q1y, p2x, p2y, q2x, q2y) {
  var o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y);
  var o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y);
  var o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y);
  var o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y);
  if (o1 !== o2 && o3 !== o4 || o1 === 0 && onSegment(p1x, p1y, p2x, p2y, q1x, q1y) || o2 === 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y) || o3 === 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) {
    return true;
  } else if (o4 === 0) {
    return onSegment(p2x, p2y, q1x, q1y, q2x, q2y);
  } else {
    return false;
  }
}

function sqr(x) {
  return x * x;
}

function dist2(vx, vy, wx, wy) {
  var x = vx - wx;
  var x$1 = vy - wy;
  return x * x + x$1 * x$1;
}

function distToLineSegmentSquared(px, py, x1, y1, x2, y2) {
  var l2 = dist2(x1, y1, x2, y2);
  if (l2 === 0) {
    return dist2(px, py, x1, y1);
  }
  var t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2));
  return dist2(px, py, x1 + t * (x2 - x1), y1 + t * (y2 - y1));
}

function isPointNearLine(px, py, line, tolerance) {
  var distanceSquared = distToLineSegmentSquared(px, py, line.start.x, line.start.y, line.end.x, line.end.y);
  return distanceSquared <= tolerance * tolerance;
}

function lineIntersectsSelection(line, selection, tolerance) {
  var normalizedSelection = normalizeSelection(selection);
  var expandedSelection = expandSelectionBox(normalizedSelection, tolerance);
  if (isPointInsideSelection(expandedSelection, line.start.x, line.start.y, undefined) || isPointInsideSelection(expandedSelection, line.end.x, line.end.y, undefined)) {
    return true;
  }
  var left = expandedSelection.x;
  var right = expandedSelection.x + expandedSelection.width;
  var top = expandedSelection.y;
  var bottom = expandedSelection.y + expandedSelection.height;
  if (doIntersect(line.start.x, line.start.y, line.end.x, line.end.y, left, top, right, top) || doIntersect(line.start.x, line.start.y, line.end.x, line.end.y, left, bottom, right, bottom) || doIntersect(line.start.x, line.start.y, line.end.x, line.end.y, left, top, left, bottom)) {
    return true;
  } else {
    return doIntersect(line.start.x, line.start.y, line.end.x, line.end.y, right, top, right, bottom);
  }
}

function rectIntersectsSelection(rect, selection) {
  var normalizedRect = normalizeRect(rect);
  var normalizedSelection = normalizeSelection(selection);
  var noHorizontalOverlap = normalizedRect.x + normalizedRect.width < normalizedSelection.x || normalizedSelection.x + normalizedSelection.width < normalizedRect.x;
  var noVerticalOverlap = normalizedRect.y + normalizedRect.height < normalizedSelection.y || normalizedSelection.y + normalizedSelection.height < normalizedRect.y;
  return !(noHorizontalOverlap || noVerticalOverlap);
}

function isClick(selection, tolerance) {
  var normalizedSelection = normalizeSelection(selection);
  if (normalizedSelection.width < tolerance) {
    return normalizedSelection.height < tolerance;
  } else {
    return false;
  }
}

function didMove(param) {
  var target = param.target;
  var origin = param.origin;
  if (origin.x !== target.x) {
    return true;
  } else {
    return origin.y !== target.y;
  }
}

function isPointNearPoint(px, py, qx, qy, tolerance) {
  if (px >= qx - tolerance && px <= qx + tolerance && py >= qy - tolerance) {
    return py <= qy + tolerance;
  } else {
    return false;
  }
}

function getRectCorner(clientX, clientY, param, tools) {
  var height = param.height;
  var width = param.width;
  var y = param.y;
  var x = param.x;
  var toolId = param.toolId;
  var elementTool = tools.find(function (tool) {
        return tool.toolId === toolId;
      });
  var match = Core__Option.map(elementTool, (function (tool) {
          return tool.engine;
        }));
  var match$1;
  if (match !== undefined && !(typeof match !== "object" || match.TAG !== "Rect")) {
    var match$2 = match._0;
    match$1 = [
      Core__Option.getOr(match$2.canResizeHorizontally, true),
      Core__Option.getOr(match$2.canResizeVertically, true)
    ];
  } else {
    match$1 = [
      true,
      true
    ];
  }
  var canResizeVertically = match$1[1];
  var canResizeHorizontally = match$1[0];
  var corner = isPointNearPoint(clientX, clientY, x, y, Canvas__Constants.tolerance) ? "TopLeft" : (
      isPointNearPoint(clientX, clientY, x + width, y, Canvas__Constants.tolerance) ? "TopRight" : (
          isPointNearPoint(clientX, clientY, x, y + height, Canvas__Constants.tolerance) ? "BottomLeft" : (
              isPointNearPoint(clientX, clientY, x + width, y + height, Canvas__Constants.tolerance) ? "BottomRight" : (
                  clientX >= x + Canvas__Constants.tolerance && clientX <= x + width - Canvas__Constants.tolerance ? (
                      clientY >= y - Canvas__Constants.tolerance && clientY <= y + Canvas__Constants.tolerance ? "Top" : (
                          clientY >= y + height - Canvas__Constants.tolerance && clientY <= y + height + Canvas__Constants.tolerance ? "Bottom" : undefined
                        )
                    ) : (
                      clientY >= y + Canvas__Constants.tolerance && clientY <= y + height - Canvas__Constants.tolerance ? (
                          clientX >= x - Canvas__Constants.tolerance && clientX <= x + Canvas__Constants.tolerance ? "Left" : (
                              clientX >= x + width - Canvas__Constants.tolerance && clientX <= x + width + Canvas__Constants.tolerance ? "Right" : undefined
                            )
                        ) : undefined
                    )
                )
            )
        )
    );
  if (corner === undefined) {
    return ;
  }
  switch (corner) {
    case "Start" :
    case "End" :
        return ;
    case "TopLeft" :
        if (canResizeHorizontally) {
          if (canResizeVertically) {
            return "TopLeft";
          } else {
            return "Left";
          }
        } else if (canResizeVertically) {
          return "Top";
        } else {
          return ;
        }
    case "TopRight" :
        if (canResizeHorizontally) {
          if (canResizeVertically) {
            return "TopRight";
          } else {
            return "Right";
          }
        } else if (canResizeVertically) {
          return "Top";
        } else {
          return ;
        }
    case "BottomLeft" :
        if (canResizeHorizontally) {
          if (canResizeVertically) {
            return "BottomLeft";
          } else {
            return "Left";
          }
        } else if (canResizeVertically) {
          return "Bottom";
        } else {
          return ;
        }
    case "BottomRight" :
        if (canResizeHorizontally) {
          if (canResizeVertically) {
            return "BottomRight";
          } else {
            return "Right";
          }
        } else if (canResizeVertically) {
          return "Bottom";
        } else {
          return ;
        }
    case "Top" :
        if (canResizeVertically) {
          return "Top";
        } else {
          return ;
        }
    case "Bottom" :
        if (canResizeVertically) {
          return "Bottom";
        } else {
          return ;
        }
    case "Left" :
        if (canResizeHorizontally) {
          return "Left";
        } else {
          return ;
        }
    case "Right" :
        if (canResizeHorizontally) {
          return "Right";
        } else {
          return ;
        }
    
  }
}

function getLineCorner(clientX, clientY, param, tools) {
  var end = param.end;
  var start = param.start;
  var toolId = param.toolId;
  var elementTool = tools.find(function (tool) {
        return tool.toolId === toolId;
      });
  var match = Core__Option.map(elementTool, (function (tool) {
          return tool.engine;
        }));
  var match$1;
  if (match !== undefined && !(typeof match !== "object" || match.TAG === "Rect")) {
    var match$2 = match._0;
    match$1 = [
      Core__Option.getOr(match$2.canResizeStart, true),
      Core__Option.getOr(match$2.canResizeEnd, true)
    ];
  } else {
    match$1 = [
      true,
      true
    ];
  }
  var corner = isPointNearPoint(clientX, clientY, start.x, start.y, Canvas__Constants.tolerance) ? "Start" : (
      isPointNearPoint(clientX, clientY, end.x, end.y, Canvas__Constants.tolerance) ? "End" : undefined
    );
  if (corner === undefined) {
    return ;
  }
  switch (corner) {
    case "Start" :
        if (match$1[0]) {
          return "Start";
        } else {
          return ;
        }
    case "End" :
        if (match$1[1]) {
          return "End";
        } else {
          return ;
        }
    default:
      return ;
  }
}

function getRectCursor(clientX, clientY, rect, tools) {
  var corner = getRectCorner(clientX, clientY, normalizeRect(rect), tools);
  if (corner === undefined) {
    return "Default";
  }
  switch (corner) {
    case "Start" :
    case "End" :
        return "Default";
    case "TopRight" :
    case "BottomLeft" :
        return "NESWResize";
    case "TopLeft" :
    case "BottomRight" :
        return "NWSEResize";
    case "Top" :
    case "Bottom" :
        return "NSResize";
    case "Left" :
    case "Right" :
        return "EWResize";
    
  }
}

function getLineCursor(clientX, clientY, line, tools) {
  var corner = getLineCorner(clientX, clientY, line, tools);
  if (corner === undefined) {
    return "Default";
  }
  switch (corner) {
    case "Start" :
    case "End" :
        return "Grab";
    default:
      return "Default";
  }
}

function getElementCorner(clientX, clientY, element, tools) {
  if (element.TAG === "Line") {
    return getLineCorner(clientX, clientY, element._0, tools);
  } else {
    return getRectCorner(clientX, clientY, element._0, tools);
  }
}

function getCursorType(cursor) {
  switch (cursor) {
    case "Default" :
        return "default";
    case "NESWResize" :
        return "nesw-resize";
    case "NWSEResize" :
        return "nwse-resize";
    case "Grab" :
        return "grab";
    case "NSResize" :
        return "ns-resize";
    case "EWResize" :
        return "ew-resize";
    
  }
}

function resizeRect(rect, clientX, clientY, corner) {
  switch (corner) {
    case "Start" :
    case "End" :
        return rect;
    case "TopLeft" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: clientX,
                y: clientY,
                width: rect.x + rect.width - clientX,
                height: rect.y + rect.height - clientY
              };
    case "TopRight" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: rect.x,
                y: clientY,
                width: clientX - rect.x,
                height: rect.y + rect.height - clientY
              };
    case "BottomLeft" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: clientX,
                y: rect.y,
                width: rect.x + rect.width - clientX,
                height: clientY - rect.y
              };
    case "BottomRight" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: rect.x,
                y: rect.y,
                width: clientX - rect.x,
                height: clientY - rect.y
              };
    case "Top" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: rect.x,
                y: clientY,
                width: rect.width,
                height: rect.y + rect.height - clientY
              };
    case "Bottom" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: clientY - rect.y
              };
    case "Left" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: clientX,
                y: rect.y,
                width: rect.x + rect.width - clientX,
                height: rect.height
              };
    case "Right" :
        return {
                id: rect.id,
                toolId: rect.toolId,
                zIndex: rect.zIndex,
                label: rect.label,
                x: rect.x,
                y: rect.y,
                width: clientX - rect.x,
                height: rect.height
              };
    
  }
}

function resizeLine(line, clientX, clientY, corner) {
  switch (corner) {
    case "Start" :
        return {
                id: line.id,
                toolId: line.toolId,
                zIndex: line.zIndex,
                label: line.label,
                start: {
                  x: clientX,
                  y: clientY
                },
                end: line.end
              };
    case "End" :
        return {
                id: line.id,
                toolId: line.toolId,
                zIndex: line.zIndex,
                label: line.label,
                start: line.start,
                end: {
                  x: clientX,
                  y: clientY
                }
              };
    default:
      return line;
  }
}

var epsilon = 1e-10;

export {
  normalizeRect ,
  normalizeSelection ,
  expandSelectionBox ,
  isPointInsideSelection ,
  onSegment ,
  epsilon ,
  orientation ,
  doIntersect ,
  sqr ,
  dist2 ,
  distToLineSegmentSquared ,
  isPointNearLine ,
  lineIntersectsSelection ,
  rectIntersectsSelection ,
  isClick ,
  didMove ,
  isPointNearPoint ,
  getRectCorner ,
  getLineCorner ,
  getRectCursor ,
  getLineCursor ,
  getElementCorner ,
  getCursorType ,
  resizeRect ,
  resizeLine ,
}
/* No side effect */
